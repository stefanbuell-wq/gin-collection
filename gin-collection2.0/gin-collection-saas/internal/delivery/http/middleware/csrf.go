package middleware

import (
	"crypto/rand"
	"encoding/hex"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/yourusername/gin-collection-saas/internal/infrastructure/cache"
	"github.com/yourusername/gin-collection-saas/pkg/logger"
)

const (
	csrfTokenLength  = 32
	csrfTokenExpiry  = 24 * time.Hour
	csrfHeaderName   = "X-CSRF-Token"
	csrfCookieName   = "csrf_token"
	csrfRedisPrefix  = "csrf:"
)

// CSRFMiddleware handles CSRF protection
type CSRFMiddleware struct {
	redisClient  *cache.RedisClient
	secureCookie bool
}

// NewCSRFMiddleware creates a new CSRF middleware
func NewCSRFMiddleware(redisClient *cache.RedisClient, secureCookie bool) *CSRFMiddleware {
	return &CSRFMiddleware{
		redisClient:  redisClient,
		secureCookie: secureCookie,
	}
}

// GenerateToken generates a new CSRF token and stores it in Redis
func (m *CSRFMiddleware) GenerateToken() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Generate random token
		tokenBytes := make([]byte, csrfTokenLength)
		if _, err := rand.Read(tokenBytes); err != nil {
			logger.Error("Failed to generate CSRF token", "error", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate security token"})
			c.Abort()
			return
		}
		token := hex.EncodeToString(tokenBytes)

		// Store token in Redis if available
		if m.redisClient != nil {
			key := csrfRedisPrefix + token
			err := m.redisClient.Set(c.Request.Context(), key, "valid", csrfTokenExpiry)
			if err != nil {
				logger.Error("Failed to store CSRF token in Redis", "error", err)
				// Continue without Redis - token will still be validated via cookie
			}
		}

		// Set cookie with token
		c.SetCookie(
			csrfCookieName,
			token,
			int(csrfTokenExpiry.Seconds()),
			"/",
			"",
			m.secureCookie, // Secure flag (HTTPS only)
			false,          // HttpOnly = false so JS can read it
		)

		// Also send token in response header for SPA convenience
		c.Header(csrfHeaderName, token)

		// Store token in context for handlers that need it
		c.Set("csrf_token", token)

		c.Next()
	}
}

// ValidateToken validates CSRF token on state-changing requests
func (m *CSRFMiddleware) ValidateToken() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Skip validation for safe methods
		if c.Request.Method == "GET" || c.Request.Method == "HEAD" || c.Request.Method == "OPTIONS" {
			c.Next()
			return
		}

		// Get token from header
		headerToken := c.GetHeader(csrfHeaderName)
		if headerToken == "" {
			logger.Debug("CSRF token missing from header")
			c.JSON(http.StatusForbidden, gin.H{
				"error": "CSRF token required",
				"code":  "CSRF_TOKEN_MISSING",
			})
			c.Abort()
			return
		}

		// Get token from cookie
		cookieToken, err := c.Cookie(csrfCookieName)
		if err != nil {
			logger.Debug("CSRF cookie not found", "error", err)
			c.JSON(http.StatusForbidden, gin.H{
				"error": "CSRF token invalid",
				"code":  "CSRF_COOKIE_MISSING",
			})
			c.Abort()
			return
		}

		// Compare tokens (double-submit pattern)
		if headerToken != cookieToken {
			logger.Warn("CSRF token mismatch", "header", headerToken[:8]+"...", "cookie", cookieToken[:8]+"...")
			c.JSON(http.StatusForbidden, gin.H{
				"error": "CSRF token invalid",
				"code":  "CSRF_TOKEN_MISMATCH",
			})
			c.Abort()
			return
		}

		// Validate token exists in Redis (if available)
		if m.redisClient != nil {
			key := csrfRedisPrefix + headerToken
			exists, err := m.redisClient.Exists(c.Request.Context(), key)
			if err != nil {
				logger.Error("Failed to validate CSRF token in Redis", "error", err)
				// Continue anyway - double-submit provides base protection
			} else if !exists {
				logger.Warn("CSRF token not found in Redis (expired or invalid)")
				c.JSON(http.StatusForbidden, gin.H{
					"error": "CSRF token expired",
					"code":  "CSRF_TOKEN_EXPIRED",
				})
				c.Abort()
				return
			}
		}

		logger.Debug("CSRF token validated successfully")
		c.Next()
	}
}

// GetCSRFToken endpoint handler to get a new CSRF token
func (m *CSRFMiddleware) GetCSRFToken() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Token is already generated by GenerateToken middleware
		token, exists := c.Get("csrf_token")
		if !exists {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "CSRF token not generated"})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"csrf_token": token,
		})
	}
}
